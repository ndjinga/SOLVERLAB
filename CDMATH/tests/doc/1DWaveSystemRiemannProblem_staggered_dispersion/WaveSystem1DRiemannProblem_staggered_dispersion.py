#!/usr/bin/env python
# -*-coding:utf-8 -*

import solverlab
import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import matplotlib.animation as manimation
import sys

###############################################################################################
# The aim of this test is to study how dispersed waves can be generated by staggered schemes. #
# For that sake we vary the coefficient of the upwinding matrix to generate dispersed waves.   #
# The numerical results are plotted on the same ictures and a video is generated.              #
###############################################################################################

disp_coeff1=0.1
disp_coeff2=1
disp_coeff3=5
disp_coeff4=-1

p0=155.e5#reference pressure in a pressurised nuclear vessel
c0=700.#reference sound speed for water at 155 bars
rho0=p0/c0*c0#reference density
precision=1e-5

def initial_conditions_Riemann_problem(a,b,nx):
    print( "Initial data Riemann problem")

    dx = (b - a) / nx #space step
    x=[a+0.5*dx + i*dx for i in range(nx)]   # array of cell center (1D mesh)

    u_initial = [ 0 ]*nx
    p_initial = [ (xi<(a+b)/2)*p0 + (xi>=(a+b)/2)*p0/2  for xi in x]

    return p_initial, u_initial

    
def staggeredMatrices(coeff,dispersion_coeff):
    dim=1
    S1=solverlab.Matrix(dim+1,dim+1)
    S2=solverlab.Matrix(dim+1,dim+1)

    for i in range(dim):
        S1[0,i+1]=c0*c0*(1.+dispersion_coeff)/2*coeff
        S1[i+1,0]=      (1.-dispersion_coeff)/2*coeff
        S2[0,i+1]=c0*c0*(1.-dispersion_coeff)/2*coeff
        S2[i+1,0]=      (1.+dispersion_coeff)/2*coeff
       
    return S1,S2
    
    
def computeStaggeredDivergenceMatrix(a,b,nx,nbVoisinsMax,dt, dispersion_coeff):
    nbCells = nx
    dx=(b-a)/nx
    dim=1
    nbComp=dim+1
    normal=solverlab.Vector(dim)

    implMat=solverlab.SparseMatrixPetsc(nbCells*nbComp,nbCells*nbComp,(nbVoisinsMax+1)*nbComp)

    S1,S2 = staggeredMatrices(dt/dx, dispersion_coeff)
    for k in range(nbCells):#On parcourt les cellules
        if ( k==0) :
            implMat.addValue(k*nbComp, (k+1)*nbComp, S1)
            implMat.addValue(k*nbComp,  k   *nbComp, S1*(-1.))
        elif ( k==nbCells-1) :
            implMat.addValue(k*nbComp,  k   *nbComp, S2)
            implMat.addValue(k*nbComp, (k-1)*nbComp, S2*(-1.))
        else :
            implMat.addValue(k*nbComp, (k+1)*nbComp, S1)
            implMat.addValue(k*nbComp,  k   *nbComp, S1*(-1.))

            implMat.addValue(k*nbComp,  k   *nbComp, S2)
            implMat.addValue(k*nbComp, (k-1)*nbComp, S2*(-1.))
        
    return implMat

def WaveSystemVF(ntmax, tmax, cfl, a,b,nx, output_freq, meshName):
    dim=1
    nbCells = nx
    
    dt = 0.
    time = 0.
    it=0;
    isStationary=False
    
    dx=(b-a)/nx
    dt = cfl * dx / c0

    nbVoisinsMax=2
    isImplicit=False
    
    #iteration vectors
    Un =solverlab.Vector(nbCells*(dim+1))
    dUn=solverlab.Vector(nbCells*(dim+1))
    
    Un2 =solverlab.Vector(nbCells*(dim+1))
    dUn2=solverlab.Vector(nbCells*(dim+1))

    Un3 =solverlab.Vector(nbCells*(dim+1))
    dUn3=solverlab.Vector(nbCells*(dim+1))
    
    Un4 =solverlab.Vector(nbCells*(dim+1))
    dUn4=solverlab.Vector(nbCells*(dim+1))
    
    # Initial conditions #
    print("Construction of the initial condition …")
    pressure_field1, velocity_field1 = initial_conditions_Riemann_problem(a,b,nx)
    pressure_field2, velocity_field2 = initial_conditions_Riemann_problem(a,b,nx)
    pressure_field3, velocity_field3 = initial_conditions_Riemann_problem(a,b,nx)
    pressure_field4, velocity_field4 = initial_conditions_Riemann_problem(a,b,nx)
    max_initial_p=max(pressure_field1)
    min_initial_p=min(pressure_field1)
    max_initial_v=max(velocity_field1)
    min_initial_v=min(velocity_field1)
    
    for k in range(nbCells):
        Un[k*(dim+1)+0] =     pressure_field1[k]
        Un[k*(dim+1)+1] =rho0*velocity_field1[k]
        Un2[k*(dim+1)+0] =     pressure_field2[k]
        Un2[k*(dim+1)+1] =rho0*velocity_field2[k]
        Un3[k*(dim+1)+0] =     pressure_field3[k]
        Un3[k*(dim+1)+1] =rho0*velocity_field3[k]
        Un4[k*(dim+1)+0] =     pressure_field4[k]
        Un4[k*(dim+1)+1] =rho0*velocity_field4[k]

    # Video settings
    FFMpegWriter = manimation.writers['ffmpeg']
    metadata = dict(title="Staggered finite volume method for the 1D Wave System", artist = "CEA Saclay", comment="Study of dispersion waves")
    writer=FFMpegWriter(fps=10, metadata=metadata, codec='h264')
    with writer.saving(plt.figure(), "1DWaveSystem_FV_Staggered_dispersion"+".mp4", ntmax):
        #sauvegarde de la donnée initiale
        plt.xlabel('x (m)')
        plt.ylabel('Pressure -Pa)')
        plt.xlim(a,b)
        plt.ylim( min_initial_p - 0.1*(max_initial_p-min_initial_p), max_initial_p +  0.1*(max_initial_p-min_initial_p) )
        plt.title("Riemann problem for Wave system \n Staggered scheme on " + str(nx) + " cells")
        line1, = plt.plot([a+0.5*dx + i*dx for i in range(nx)], pressure_field1, label='Staggered dispersion coefficient '+str(disp_coeff1)) #new picture for video # Returns a tuple of line objects, thus the comma
        line2, = plt.plot([a+0.5*dx + i*dx for i in range(nx)], pressure_field2, label='Staggered dispersion coefficient '+str(disp_coeff2)) #new picture for video # Returns a tuple of line objects, thus the comma
        line3, = plt.plot([a+0.5*dx + i*dx for i in range(nx)], pressure_field3, label='Staggered dispersion coefficient '+str(disp_coeff3)) #new picture for video # Returns a tuple of line objects, thus the comma
        line4, = plt.plot([a+0.5*dx + i*dx for i in range(nx)], pressure_field4, label='Staggered dispersion coefficient '+str(disp_coeff4)) #new picture for video # Returns a tuple of line objects, thus the comma
        plt.legend()
        writer.grab_frame()
        plt.savefig("WaveSystem"+str(dim)+"DStaggered_dispersion"+meshName+"_pressure"+"_0"+".png")
        #np.savetxt( "WaveSystem"+str(dim)+"DStaggered"+str(disp_coeff1)+meshName+"_pressure"+"_0"+".txt", pressure_field1, delimiter="\n")
        #np.savetxt( "WaveSystem"+str(dim)+"DStaggered"+str(disp_coeff1)+meshName+"_velocity"+"_0"+".txt", velocity_field1, delimiter="\n")
        
        divMat1=computeStaggeredDivergenceMatrix(a,b,nx,nbVoisinsMax,dt, disp_coeff1)
        divMat2=computeStaggeredDivergenceMatrix(a,b,nx,nbVoisinsMax,dt, disp_coeff2)
        divMat3=computeStaggeredDivergenceMatrix(a,b,nx,nbVoisinsMax,dt, disp_coeff3)
        divMat4=computeStaggeredDivergenceMatrix(a,b,nx,nbVoisinsMax,dt, disp_coeff4)
            
        iterGMRESMax=50
    
        divMat1.diagonalShift(1)#only after  filling all coefficients
        LS=solverlab.LinearSolver(divMat1,Un,iterGMRESMax, precision, "GMRES","ILU")
    
        divMat2.diagonalShift(1)#only after  filling all coefficients
        LS2=solverlab.LinearSolver(divMat2,Un2,iterGMRESMax, precision, "GMRES","ILU")
    
        divMat3.diagonalShift(1)#only after  filling all coefficients
        LS3=solverlab.LinearSolver(divMat3,Un3,iterGMRESMax, precision, "GMRES","ILU")
    
        divMat4.diagonalShift(1)#only after  filling all coefficients
        LS4=solverlab.LinearSolver(divMat4,Un4,iterGMRESMax, precision, "GMRES","ILU")
    
        print("Starting computation of the linear wave system with staggered scheme …")
        
        # Starting time loop
        while (it<ntmax and time <= tmax and not isStationary):
            dUn=Un.deepCopy()
            LS.setSndMember(Un)
            Un=LS.solve();
            if(not LS.getStatus()):
                print( "Linear system did not converge ", LS.getNumberOfIter(), " GMRES iterations")
                raise ValueError("Pas de convergence du système linéaire");
            dUn-=Un
    
            dUn2=Un2.deepCopy()
            LS2.setSndMember(Un2)
            Un2=LS2.solve();
            if(not LS2.getStatus()):
                print( "Linear system did not converge  ", LS2.getNumberOfIter(), " GMRES iterations")
                raise ValueError("Pas de convergence du système linéaire");
            dUn2-=Un2
    
            dUn3=Un3.deepCopy()
            LS3.setSndMember(Un3)
            Un3=LS3.solve();
            if(not LS3.getStatus()):
                print( "Linear system did not converge ", LS3.getNumberOfIter(), " GMRES iterations")
                raise ValueError("Pas de convergence du système linéaire");
            dUn3-=Un3
    
            dUn4=Un4.deepCopy()
            LS4.setSndMember(Un4)
            Un4=LS4.solve();
            if(not LS4.getStatus()):
                print( "Linear system did not converge ", LS4.getNumberOfIter(), " GMRES iterations")
                raise ValueError("Pas de convergence du système linéaire");
            dUn4-=Un4
    
            for k in range(nbCells):
                pressure_field1[k] = Un[k*(dim+1)+0]
                velocity_field1[k] = Un[k*(dim+1)+1] / rho0
                pressure_field2[k] = Un2[k*(dim+1)+0]
                velocity_field2[k] = Un2[k*(dim+1)+1] / rho0
                pressure_field3[k] = Un3[k*(dim+1)+0]
                velocity_field3[k] = Un3[k*(dim+1)+1] / rho0
                pressure_field4[k] = Un4[k*(dim+1)+0]
                velocity_field4[k] = Un4[k*(dim+1)+1] / rho0
    
            line1.set_ydata(pressure_field1)
            line2.set_ydata(pressure_field2)
            line3.set_ydata(pressure_field3)
            line4.set_ydata(pressure_field4)
            writer.grab_frame()
    
            time=time+dt;
            it=it+1;
        
            #Sauvegardes
            if(it==1 or it%output_freq==0 or it>=ntmax or isStationary or time >=tmax):
                print("-- Iter: " + str(it) + ", Time: " + str(time) + ", dt: " + str(dt))
                if(isImplicit):
                    print( "Linear system converged in ", LS.getNumberOfIter(), " GMRES iterations")
    
                #np.savetxt("WaveSystem"+str(dim)+"DStaggered"+str(disp_coeff1)   +meshName+"_pressure"+str(it)+".txt", pressure_field1          , delimiter="\n")
                #np.savetxt("WaveSystem"+str(dim)+"DStaggered"+str(disp_coeff1)   +meshName+"_velocity"+str(it)+".txt", velocity_field1          , delimiter="\n")
                plt.savefig("WaveSystem"+str(dim)+"DStaggered_dispersion"+meshName+"_pressure"+str(it)+".png")
    
                print()
    print("-- Iter: " + str(it) + ", Time: " + str(time) + ", dt: " + str(dt))

    if(it>=ntmax):
        print( "Nombre de pas de temps maximum ntmax= ", ntmax, " atteint")
        return
    elif(isStationary):
        print( "Régime stationnaire atteint au pas de temps ", it, ", t= ", time)
        print( "------------------------------------------------------------------------------------")

        plt.savefig("WaveSystem"+str(dim)+"DStaggered_dispersion"+meshName+"_pressure_Stat.png")

        return
    else:
        print( "Temps maximum Tmax= ", tmax, " atteint")
        return


def solve( a,b,nx, meshName, meshType, cfl):

    print( "Resolution of the Wave system in dimension 1 on "+str(nx)+ " cells")
    print( "Initial data : ", "Riemann problem")
    print( "Boundary conditions : ", "Neumann")
    print( "Mesh name : ",meshName , ", ", nx, " cells")
    
    # Problem data
    tmax = 10000.
    ntmax = 50
    output_freq = 1

    WaveSystemVF(ntmax, tmax, cfl, a,b,nx, output_freq, meshName)
    
    return
    

if __name__ == """__main__""":
    a=0.
    b=1.
    nx=100
    cfl=0.99
    solve( a,b,nx,"SquareRegularSquares","RegularSquares",cfl)
